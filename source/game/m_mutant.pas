{
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                           Quake 2 Freepascal Port 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


--------------------------------------------------------------------------------
  Contributors:
--------------------------------------------------------------------------------
    Lars aka L505 (started FPC port)
    http://z505.com
    

--------------------------------------------------------------------------------
 Notes regarding freepascal port:
--------------------------------------------------------------------------------

 - see below for delphi notes, conversion notes, and copyright
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
}


{$ALIGN ON}{$MINENUMSIZE 4}
{----------------------------------------------------------------------------}
{                                                                            }
{ File(s): game\m_mutant.c                                                   }
{          game\m_mutant.h                                                   }
{ Content: Saving and loading games                                          }
{                                                                            }
{ Initial conversion by: Carl A Kenner (carlkenner@hotmail.com)              }
{ Initial conversion on: 1-Mar-2002                                          }
{                                                                            }
{ This File contains part of convertion of Quake2 source to ObjectPascal.    }
{ More information about this project can be found at:                       }
{ http://www.sulaco.co.za/quake2/                                            }
{                                                                            }
{ Copyright (C) 1997-2001 Id Software, Inc.                                  }
{                                                                            }
{ This program is free software; you can redistribute it and/or              }
{ modify it under the terms of the GNU General Public License                }
{ as published by the Free Software Foundation; either version 2             }
{ of the License, or (at your option) any later version.                     }
{                                                                            }
{ This program is distributed in the hope that it will be useful,            }
{ but WITHOUT ANY WARRANTY; without even the implied warranty of             }
{ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                       }
{                                                                            }
{ See the GNU General Public License for more details.                       }
{                                                                            }
{----------------------------------------------------------------------------}
{ Updated on: 3-Mar-2002                                                     }
{ Updated by: Carl A Kenner                                                  }
{                                                                            }
{----------------------------------------------------------------------------}
{ * Still dependent (to compile correctly) on:                               }
{ g_ai, g_monster, g_weapon, g_combat, m_move                                }
{----------------------------------------------------------------------------}
{ * TODO:                                                                    }
{ check for errors                                                           }
{----------------------------------------------------------------------------}
unit m_mutant;

interface

uses
  g_local;

// G:\quake2\baseq2\models/monsters/mutant

// This [part of the - CAK] file generated by ModelGen - Do NOT Modify
const
  FRAME_attack01 = 0;
  FRAME_attack02 = 1;
  FRAME_attack03 = 2;
  FRAME_attack04 = 3;
  FRAME_attack05 = 4;
  FRAME_attack06 = 5;
  FRAME_attack07 = 6;
  FRAME_attack08 = 7;
  FRAME_attack09 = 8;
  FRAME_attack10 = 9;
  FRAME_attack11 = 10;
  FRAME_attack12 = 11;
  FRAME_attack13 = 12;
  FRAME_attack14 = 13;
  FRAME_attack15 = 14;
  FRAME_death101 = 15;
  FRAME_death102 = 16;
  FRAME_death103 = 17;
  FRAME_death104 = 18;
  FRAME_death105 = 19;
  FRAME_death106 = 20;
  FRAME_death107 = 21;
  FRAME_death108 = 22;
  FRAME_death109 = 23;
  FRAME_death201 = 24;
  FRAME_death202 = 25;
  FRAME_death203 = 26;
  FRAME_death204 = 27;
  FRAME_death205 = 28;
  FRAME_death206 = 29;
  FRAME_death207 = 30;
  FRAME_death208 = 31;
  FRAME_death209 = 32;
  FRAME_death210 = 33;
  FRAME_pain101  = 34;
  FRAME_pain102  = 35;
  FRAME_pain103  = 36;
  FRAME_pain104  = 37;
  FRAME_pain105  = 38;
  FRAME_pain201  = 39;
  FRAME_pain202  = 40;
  FRAME_pain203  = 41;
  FRAME_pain204  = 42;
  FRAME_pain205  = 43;
  FRAME_pain206  = 44;
  FRAME_pain301  = 45;
  FRAME_pain302  = 46;
  FRAME_pain303  = 47;
  FRAME_pain304  = 48;
  FRAME_pain305  = 49;
  FRAME_pain306  = 50;
  FRAME_pain307  = 51;
  FRAME_pain308  = 52;
  FRAME_pain309  = 53;
  FRAME_pain310  = 54;
  FRAME_pain311  = 55;
  FRAME_run03    = 56;
  FRAME_run04    = 57;
  FRAME_run05    = 58;
  FRAME_run06    = 59;
  FRAME_run07    = 60;
  FRAME_run08    = 61;
  FRAME_stand101 = 62;
  FRAME_stand102 = 63;
  FRAME_stand103 = 64;
  FRAME_stand104 = 65;
  FRAME_stand105 = 66;
  FRAME_stand106 = 67;
  FRAME_stand107 = 68;
  FRAME_stand108 = 69;
  FRAME_stand109 = 70;
  FRAME_stand110 = 71;
  FRAME_stand111 = 72;
  FRAME_stand112 = 73;
  FRAME_stand113 = 74;
  FRAME_stand114 = 75;
  FRAME_stand115 = 76;
  FRAME_stand116 = 77;
  FRAME_stand117 = 78;
  FRAME_stand118 = 79;
  FRAME_stand119 = 80;
  FRAME_stand120 = 81;
  FRAME_stand121 = 82;
  FRAME_stand122 = 83;
  FRAME_stand123 = 84;
  FRAME_stand124 = 85;
  FRAME_stand125 = 86;
  FRAME_stand126 = 87;
  FRAME_stand127 = 88;
  FRAME_stand128 = 89;
  FRAME_stand129 = 90;
  FRAME_stand130 = 91;
  FRAME_stand131 = 92;
  FRAME_stand132 = 93;
  FRAME_stand133 = 94;
  FRAME_stand134 = 95;
  FRAME_stand135 = 96;
  FRAME_stand136 = 97;
  FRAME_stand137 = 98;
  FRAME_stand138 = 99;
  FRAME_stand139 = 100;
  FRAME_stand140 = 101;
  FRAME_stand141 = 102;
  FRAME_stand142 = 103;
  FRAME_stand143 = 104;
  FRAME_stand144 = 105;
  FRAME_stand145 = 106;
  FRAME_stand146 = 107;
  FRAME_stand147 = 108;
  FRAME_stand148 = 109;
  FRAME_stand149 = 110;
  FRAME_stand150 = 111;
  FRAME_stand151 = 112;
  FRAME_stand152 = 113;
  FRAME_stand153 = 114;
  FRAME_stand154 = 115;
  FRAME_stand155 = 116;
  FRAME_stand156 = 117;
  FRAME_stand157 = 118;
  FRAME_stand158 = 119;
  FRAME_stand159 = 120;
  FRAME_stand160 = 121;
  FRAME_stand161 = 122;
  FRAME_stand162 = 123;
  FRAME_stand163 = 124;
  FRAME_stand164 = 125;
  FRAME_walk01   = 126;
  FRAME_walk02   = 127;
  FRAME_walk03   = 128;
  FRAME_walk04   = 129;
  FRAME_walk05   = 130;
  FRAME_walk06   = 131;
  FRAME_walk07   = 132;
  FRAME_walk08   = 133;
  FRAME_walk09   = 134;
  FRAME_walk10   = 135;
  FRAME_walk11   = 136;
  FRAME_walk12   = 137;
  FRAME_walk13   = 138;
  FRAME_walk14   = 139;
  FRAME_walk15   = 140;
  FRAME_walk16   = 141;
  FRAME_walk17   = 142;
  FRAME_walk18   = 143;
  FRAME_walk19   = 144;
  FRAME_walk20   = 145;
  FRAME_walk21   = 146;
  FRAME_walk22   = 147;
  FRAME_walk23   = 148;

  MODEL_SCALE    = 1.000000;

procedure SP_monster_mutant(self: edict_p); cdecl;

implementation

uses
  g_ai, g_monster, g_weapon, g_combat, m_move,
  q_shared, GameUnit, g_misc, g_utils, g_main, g_local_add,
  game_add, CPas;

(*
==============================================================================

mutant

==============================================================================
*)
Var
  sound_swing,
  sound_hit,
  sound_hit2,
  sound_death,
  sound_idle,
  sound_pain1,
  sound_pain2,
  sound_sight,
  sound_search,
  sound_step1,
  sound_step2,
  sound_step3,
  sound_thud: Integer;

//
// SOUNDS
//

procedure mutant_step(self: edict_p); cdecl;
Var n: Integer;
begin
  n := (rand() + 1) mod 3;
  if n = 0 then
    gi.sound(self, CHAN_VOICE, sound_step1, 1, ATTN_NORM, 0)
  else if n = 1 then
    gi.sound(self, CHAN_VOICE, sound_step2, 1, ATTN_NORM, 0)
  else
    gi.sound(self, CHAN_VOICE, sound_step3, 1, ATTN_NORM, 0);
end;

procedure mutant_sight(self, other: edict_p); cdecl;
begin
  gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
end;

procedure mutant_search(self: edict_p); cdecl;
begin
  gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
end;

procedure mutant_swing(self: edict_p);
begin
  gi.sound(self, CHAN_VOICE, sound_swing, 1, ATTN_NORM, 0);
end;

//
// STAND
//

const
  mutant_frames_stand: Array[0..50] of mframe_t = (
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // 10

    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // 20

    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // 30

    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // 40

    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // 50

    (aifunc: ai_stand; dist: 0)
  );
  mutant_move_stand: mmove_t =
    (firstframe: FRAME_stand101;
     lastframe: FRAME_stand151;
     frame: @mutant_frames_stand[0]);

procedure mutant_stand(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_stand;
end;


//
// IDLE
//

procedure mutant_idle_loop(self: edict_p); cdecl;
begin
  if _random() < 0.75 then
    self.monsterinfo.nextframe := FRAME_stand155;
end;

const
  mutant_frames_idle: Array[0..12] of mframe_t = (
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0), // scratch loop start
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0; thinkfunc: mutant_idle_loop), // scratch loop end
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0),
    (aifunc: ai_stand; dist: 0)
  );

  mutant_move_idle: mmove_t =
    (firstframe: FRAME_stand152;
     lastframe: FRAME_stand164;
     frame: @mutant_frames_idle[0];
     endfunc: mutant_stand);

procedure mutant_idle(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_idle;
  gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
end;


//
// WALK
//

procedure mutant_walk(self: edict_p); cdecl; forward;

const
  mutant_frames_walk: Array[0..11] of mframe_t = (
    (aifunc: ai_walk; dist: 3),
    (aifunc: ai_walk; dist: 1),
    (aifunc: ai_walk; dist: 5),
    (aifunc: ai_walk; dist: 10),
    (aifunc: ai_walk; dist: 13),
    (aifunc: ai_walk; dist: 10),
    (aifunc: ai_walk; dist: 0),
    (aifunc: ai_walk; dist: 5),
    (aifunc: ai_walk; dist: 6),
    (aifunc: ai_walk; dist: 16),
    (aifunc: ai_walk; dist: 15),
    (aifunc: ai_walk; dist: 6)
  );
  mutant_move_walk: mmove_t =
    (firstframe: FRAME_walk05;
     lastframe: FRAME_walk16;
     frame: @mutant_frames_walk[0]);

procedure mutant_walk_loop(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_walk;
end;

const
  mutant_frames_start_walk: Array[0..3] of mframe_t = (
    (aifunc: ai_walk; dist: 5),
    (aifunc: ai_walk; dist: 5),
    (aifunc: ai_walk; dist: -2),
    (aifunc: ai_walk; dist: 1)
  );
  mutant_move_start_walk: mmove_t =
    (firstframe: FRAME_walk01;
     lastframe: FRAME_walk04;
     frame: @mutant_frames_start_walk[0];
     endfunc: mutant_walk_loop);

procedure mutant_walk(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_start_walk;
end;


//
// RUN
//

const
  mutant_frames_run: Array[0..5] of mframe_t = (
    (aifunc: ai_run; dist: 40),
    (aifunc: ai_run; dist: 40; thinkfunc: mutant_step),
    (aifunc: ai_run; dist: 24),
    (aifunc: ai_run; dist: 5; thinkfunc: mutant_step),
    (aifunc: ai_run; dist: 17),
    (aifunc: ai_run; dist: 10)
  );

  mutant_move_run: mmove_t =
    (firstframe: FRAME_run03;
     lastframe: FRAME_run08;
     frame: @mutant_frames_run[0]);

procedure mutant_run(self: edict_p); cdecl;
begin
  if (self.monsterinfo.aiflags AND AI_STAND_GROUND)>0 then
    self.monsterinfo.currentmove := @mutant_move_stand
  else
    self.monsterinfo.currentmove := @mutant_move_run;
end;


//
// MELEE
//
procedure mutant_hit_left(self: edict_p); cdecl;
Var aim: vec3_t;
begin
  VectorSet(aim, MELEE_DISTANCE, self.mins[0], 8);
  if fire_hit(Self, aim, 10 + (rand() mod 5), 100) then
    gi.sound(self, CHAN_WEAPON, sound_hit, 1, ATTN_NORM, 0)
  else
    gi.sound(self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
end;

procedure mutant_hit_right(self: edict_p); cdecl;
Var aim: vec3_t;
begin
  VectorSet(aim, MELEE_DISTANCE, self.maxs[0], 8);
  if fire_hit(Self, aim, 10 + (rand() mod 5), 100) then
    gi.sound (self, CHAN_WEAPON, sound_hit2, 1, ATTN_NORM, 0)
  else
    gi.sound (self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
end;

procedure mutant_check_refire(self: edict_p); cdecl;
begin
  if (self.enemy=Nil) or (not self.enemy.inuse) or (self.enemy.health <= 0) then
    exit;

  if ((skill.value = 3) and (_random() < 0.5)) or (range(self, self.enemy) = RANGE_MELEE) then
    self.monsterinfo.nextframe := FRAME_attack09;
end;

const
  mutant_frames_attack: Array[0..6] of mframe_t = (
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 0; thinkfunc: mutant_hit_left),
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 0; thinkfunc: mutant_hit_right),
    (aifunc: ai_charge; dist: 0; thinkfunc: mutant_check_refire)
  );
  mutant_move_attack: mmove_t =
    (firstframe: FRAME_attack09;
     lastframe: FRAME_attack15;
     frame: @mutant_frames_attack[0];
     endfunc: mutant_run);

procedure mutant_melee(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_attack;
end;


//
// ATTACK
//

procedure mutant_jump_touch(self, other: edict_p; plane: cplane_p; surf: csurface_p); cdecl;
Var point, normal: vec3_t; damage: Integer;
begin
  if self.health <= 0 then begin
    self.touch := nil;
    exit;
  end;

  if other.takedamage<>DAMAGE_NO then begin
    if VectorLength(self.velocity) > 400 then begin
      VectorCopy(self.velocity, normal);
      VectorNormalize(normal);
      VectorMA(self.s.origin, self.maxs[0], normal, point);
      damage := Trunc(40 + 10 * _random());
      T_Damage(other, self, self, self.velocity, point, normal, damage, damage, 0, MOD_UNKNOWN);
    end;
  end;

  if not M_CheckBottom(self) then begin
    if self.groundentity<>Nil then begin
      self.monsterinfo.nextframe := FRAME_attack02;
      self.touch := Nil;
    end;
    exit;
  end;

  self.touch := Nil;
end;

procedure mutant_jump_takeoff(self: edict_p); cdecl;
Var forwards: vec3_t;
begin
  gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
  AngleVectors(self.s.angles, @forwards, Nil, Nil);
  self.s.origin[2]:= self.s.origin[2] + 1;
  VectorScale(forwards, 600, self.velocity);
  self.velocity[2] := 250;
  self.groundentity := Nil;
  self.monsterinfo.aiflags := self.monsterinfo.aiflags OR AI_DUCKED;
  self.monsterinfo.attack_finished := level.time + 3;
  self.touch := mutant_jump_touch;
end;

procedure mutant_check_landing(self: edict_p); cdecl;
begin
  if self.groundentity<>Nil then begin
    gi.sound(self, CHAN_WEAPON, sound_thud, 1, ATTN_NORM, 0);
    self.monsterinfo.attack_finished := 0;
    self.monsterinfo.aiflags := self.monsterinfo.aiflags and (not AI_DUCKED);
    exit;
  end;

  if level.time > self.monsterinfo.attack_finished then
    self.monsterinfo.nextframe := FRAME_attack02
  else
    self.monsterinfo.nextframe := FRAME_attack05;
end;

const
  mutant_frames_jump: Array[0..7] of mframe_t = (
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 17),
    (aifunc: ai_charge; dist: 15; thinkfunc: mutant_jump_takeoff),
    (aifunc: ai_charge; dist: 15),
    (aifunc: ai_charge; dist: 15; thinkfunc: mutant_check_landing),
    (aifunc: ai_charge; dist: 0),
    (aifunc: ai_charge; dist: 3),
    (aifunc: ai_charge; dist: 0)
  );
  mutant_move_jump: mmove_t =
    (firstframe: FRAME_attack01;
     lastframe: FRAME_attack08;
     frame: @mutant_frames_jump[0];
     endfunc: mutant_run);

procedure mutant_jump(self: edict_p); cdecl;
begin
  self.monsterinfo.currentmove := @mutant_move_jump;
end;


//
// CHECKATTACK
//

function mutant_check_melee(self: edict_p): qboolean;
begin
  if range (self, self.enemy) = RANGE_MELEE then begin
    Result:=true;
    exit;
  end;
  Result:=false;
end;

function mutant_check_jump(self: edict_p): qboolean;
Var v: vec3_t; distance: Single;
begin
  if self.absmin[2] > self.enemy.absmin[2] + 0.75 * self.enemy.size[2] then begin
    Result:=False;
    exit;
  end;

  if self.absmax[2] < (self.enemy.absmin[2] + 0.25 * self.enemy.size[2]) then begin
    Result:=False;
    exit;
  end;

  v[0] := self.s.origin[0] - self.enemy.s.origin[0];
  v[1] := self.s.origin[1] - self.enemy.s.origin[1];
  v[2] := 0;
  distance := VectorLength(v);

  if distance < 100 then begin
    Result:=False;
    exit;
  end;
  if distance > 100 then begin
    if _random() < 0.9 then begin
      Result:=False;
      exit;
    end;
  end;

  Result:=true;
end;

function mutant_checkattack(self: edict_p): qboolean; cdecl;
begin
  if (self.enemy=Nil) or (self.enemy.health <=0) then begin
    Result:= false;
    exit;
  end;

  if mutant_check_melee(self) then begin
    self.monsterinfo.attack_state := AS_MELEE;
    result:=true;
    exit;
  end;

  if mutant_check_jump(self) then begin
    self.monsterinfo.attack_state := AS_MISSILE;
    // FIXME play a jump sound here
    result:= true;
    exit;
  end;

  Result:=false;
end;


//
// PAIN
//

Const
  mutant_frames_pain1: Array[0..4] of mframe_t = (
    (aifunc: ai_move; dist: 4),
    (aifunc: ai_move; dist: -3),
    (aifunc: ai_move; dist: -8),
    (aifunc: ai_move; dist: 2),
    (aifunc: ai_move; dist: 5)
  );
  mutant_move_pain1: mmove_t =
    (firstframe: FRAME_pain101;
     lastframe: FRAME_pain105;
     frame: @mutant_frames_pain1[0];
     endfunc: mutant_run);

  mutant_frames_pain2: Array[0..5] of mframe_t = (
    (aifunc: ai_move; dist: -24),
    (aifunc: ai_move; dist: 11),
    (aifunc: ai_move; dist: 5),
    (aifunc: ai_move; dist: -2),
    (aifunc: ai_move; dist: 6),
    (aifunc: ai_move; dist: 4)
  );
  mutant_move_pain2: mmove_t =
    (firstframe: FRAME_pain201;
     lastframe: FRAME_pain206;
     frame: @mutant_frames_pain2[0];
     endfunc: mutant_run);

  mutant_frames_pain3: Array[0..10] of mframe_t = (
    (aifunc: ai_move; dist: -22),
    (aifunc: ai_move; dist: 3),
    (aifunc: ai_move; dist: 3),
    (aifunc: ai_move; dist: 2),
    (aifunc: ai_move; dist: 1),
    (aifunc: ai_move; dist: 1),
    (aifunc: ai_move; dist: 6),
    (aifunc: ai_move; dist: 3),
    (aifunc: ai_move; dist: 2),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 1)
  );
  mutant_move_pain3: mmove_t =
    (firstframe: FRAME_pain301;
     lastframe: FRAME_pain311;
     frame: @mutant_frames_pain3[0];
     endfunc: mutant_run);

procedure mutant_pain(self, other: edict_p; kick: Single; damage: Integer); cdecl;
Var r: Single;
begin
  if self.health < self.max_health / 2 then
    self.s.skinnum := 1;

  if level.time < self.pain_debounce_time then
    exit;

  self.pain_debounce_time := level.time + 3;

  if skill.Value = 3 then
    exit; // no pain anims in nightmare

  r := _random();
  if r < 0.33 then begin
    gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
    self.monsterinfo.currentmove := @mutant_move_pain1;
  end else if r < 0.66 then begin
    gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
    self.monsterinfo.currentmove := @mutant_move_pain2;
  end else begin
    gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
    self.monsterinfo.currentmove := @mutant_move_pain3;
  end;
end;


//
// DEATH
//

procedure mutant_dead(self: edict_p); cdecl;
begin
  VectorSet(self.mins, -16, -16, -24);
  VectorSet(self.maxs, 16, 16, -8);
  Integer(self.movetype) := Integer(MOVETYPE_TOSS);
  self.svflags := self.svflags OR SVF_DEADMONSTER;
  gi.linkentity(self);

  M_FlyCheck(self);
end;

const
  mutant_frames_death1: Array[0..8] of mframe_t = (
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0)
  );
  mutant_move_death1: mmove_t = (
    firstframe: FRAME_death101;
    lastframe: FRAME_death109;
    frame: @mutant_frames_death1[0];
    endfunc: mutant_dead);

  mutant_frames_death2: Array[0..9] of mframe_t = (
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0),
    (aifunc: ai_move; dist: 0)
  );
  mutant_move_death2: mmove_t =
    (firstframe: FRAME_death201;
     lastframe: FRAME_death210;
     frame: @mutant_frames_death2[0];
     endfunc: mutant_dead);

procedure mutant_die (self: edict_p; inflictor: edict_p; attacker: edict_p; damage: Integer; const point: vec3_t); cdecl;
Var n: Integer;
begin
  if self.health <= self.gib_health then begin
    gi.sound(self, CHAN_VOICE, gi.soundindex('misc/udeath.wav'), 1, ATTN_NORM, 0);
    for n:=0 to 1 do
      ThrowGib(self, 'models/objects/gibs/bone/tris.md2', damage, GIB_ORGANIC);
    for n:=0 to 3 do
      ThrowGib(self, 'models/objects/gibs/sm_meat/tris.md2', damage, GIB_ORGANIC);
    ThrowHead(self, 'models/objects/gibs/head2/tris.md2', damage, GIB_ORGANIC);
    self.deadflag := DEAD_DEAD;
    exit;
  end;

  if self.deadflag = DEAD_DEAD then
    exit;

  gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
  self.deadflag := DEAD_DEAD;
  self.takedamage := DAMAGE_YES;
  self.s.skinnum := 1;

  if _random() < 0.5 then
    self.monsterinfo.currentmove := @mutant_move_death1
  else
    self.monsterinfo.currentmove := @mutant_move_death2;
end;


//
// SPAWN
//

(*QUAKED monster_mutant (1 .5 0) (-32 -32 -24) (32 32 32) Ambush Trigger_Spawn Sight
*)
procedure SP_monster_mutant(self: edict_p);
begin
  if deathmatch.value<>0 then begin
    G_FreeEdict(self);
    exit;
  end;

  sound_swing := gi.soundindex('mutant/mutatck1.wav');
  sound_hit := gi.soundindex('mutant/mutatck2.wav');
  sound_hit2 := gi.soundindex('mutant/mutatck3.wav');
  sound_death := gi.soundindex('mutant/mutdeth1.wav');
  sound_idle := gi.soundindex('mutant/mutidle1.wav');
  sound_pain1 := gi.soundindex('mutant/mutpain1.wav');
  sound_pain2 := gi.soundindex('mutant/mutpain2.wav');
  sound_sight := gi.soundindex('mutant/mutsght1.wav');
  sound_search := gi.soundindex('mutant/mutsrch1.wav');
  sound_step1 := gi.soundindex('mutant/step1.wav');
  sound_step2 := gi.soundindex('mutant/step2.wav');
  sound_step3 := gi.soundindex('mutant/step3.wav');
  sound_thud := gi.soundindex('mutant/thud1.wav');

  self.movetype := MOVETYPE_STEP;
  self.solid := SOLID_BBOX;
  self.s.modelindex := gi.modelindex ('models/monsters/mutant/tris.md2');
  VectorSet(self.mins, -32, -32, -24);
  VectorSet(self.maxs, 32, 32, 48);

  self.health := 300;
  self.gib_health := -120;
  self.mass := 300;

  self.pain := mutant_pain;
  self.die := mutant_die;

  self.monsterinfo.stand := mutant_stand;
  self.monsterinfo.walk := mutant_walk;
  self.monsterinfo.run := mutant_run;
  self.monsterinfo.dodge := Nil;
  self.monsterinfo.attack := mutant_jump;
  self.monsterinfo.melee := mutant_melee;
  self.monsterinfo.sight := mutant_sight;
  self.monsterinfo.search := mutant_search;
  self.monsterinfo.idle := mutant_idle;
  self.monsterinfo.checkattack := mutant_checkattack;

  gi.linkentity(self);

  self.monsterinfo.currentmove := @mutant_move_stand;

  self.monsterinfo.scale := MODEL_SCALE;
  walkmonster_start(self);
end;

end.
